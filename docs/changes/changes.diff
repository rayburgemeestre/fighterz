diff -uNr fighterz1/client/aldumb/aldumb.h fighterz2/client/aldumb/aldumb.h
--- fighterz1/client/aldumb/aldumb.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb/aldumb.h	2003-04-04 03:32:48.000000000 +0200
@@ -0,0 +1,93 @@
+/*  _______         ____    __         ___    ___
+ * \    _  \       \    /  \  /       \   \  /   /       '   '  '
+ *  |  | \  \       |  |    ||         |   \/   |         .      .
+ *  |  |  |  |      |  |    ||         ||\  /|  |
+ *  |  |  |  |      |  |    ||         || \/ |  |         '  '  '
+ *  |  |  |  |      |  |    ||         ||    |  |         .      .
+ *  |  |_/  /        \  \__//          ||    |  |
+ * /_______/ynamic    \____/niversal  /__\  /____\usic   /|  .  . ibliotheque
+ *                                                      /  \
+ *                                                     / .  \
+ * aldumb.h - The user header file for DUMB with      / / \  \
+ *            Allegro.                               | <  /   \_
+ *                                                   |  \/ /\   /
+ * Include this file if you wish to use DUMB          \_  /  > /
+ * with Allegro. It will include dumb.h for you,        | \ / /
+ * and provide extra functionality such as audio        |  ' /
+ * stream and datafile integration.                      \__/
+ */
+
+#ifndef ALDUMB_H
+#define ALDUMB_H
+
+
+#include <allegro.h>
+
+#include "dumb.h"
+
+
+#ifdef __cplusplus
+	extern "C" {
+#endif
+
+
+/* Packfile Support */
+
+void dumb_register_packfiles(void);
+
+DUMBFILE *dumbfile_open_packfile(PACKFILE *p);
+DUMBFILE *dumbfile_from_packfile(PACKFILE *p);
+
+
+/* Datafile Registration Functions */
+
+#define DUMB_DAT_DUH DAT_ID('D','U','H',' ')
+#define DUMB_DAT_IT  DAT_ID('I','T',' ',' ')
+#define DUMB_DAT_XM  DAT_ID('X','M',' ',' ')
+#define DUMB_DAT_S3M DAT_ID('S','3','M',' ')
+#define DUMB_DAT_MOD DAT_ID('M','O','D',' ')
+
+void dumb_register_dat_duh(long type);
+void dumb_register_dat_it(long type);
+void dumb_register_dat_xm(long type);
+void dumb_register_dat_s3m(long type);
+void dumb_register_dat_mod(long type);
+
+
+/* DUH Playing Functions */
+
+typedef struct AL_DUH_PLAYER AL_DUH_PLAYER;
+
+AL_DUH_PLAYER *al_start_duh(DUH *duh, int n_channels, long pos, float volume, long bufsize, int freq);
+void al_stop_duh(AL_DUH_PLAYER *dp);
+void al_pause_duh(AL_DUH_PLAYER *dp);
+void al_resume_duh(AL_DUH_PLAYER *dp);
+void al_duh_set_priority(AL_DUH_PLAYER *dp, int priority);
+void al_duh_set_volume(AL_DUH_PLAYER *dp, float volume);
+int al_poll_duh(AL_DUH_PLAYER *dp);
+long al_duh_get_position(AL_DUH_PLAYER *dp);
+
+AL_DUH_PLAYER *al_duh_encapsulate_sigrenderer(DUH_SIGRENDERER *sigrenderer, float volume, long bufsize, int freq);
+DUH_SIGRENDERER *al_duh_get_sigrenderer(AL_DUH_PLAYER *dp);
+
+/* IMPORTANT: This function will return NULL if the music has ended. */
+DUH_SIGRENDERER *al_duh_decompose_to_sigrenderer(AL_DUH_PLAYER *dp);
+
+#ifdef DUMB_DECLARE_DEPRECATED
+
+AL_DUH_PLAYER *al_duh_encapsulate_renderer(DUH_SIGRENDERER *dr, float volume, long bufsize, int freq) DUMB_DEPRECATED;
+DUH_SIGRENDERER *al_duh_get_renderer(AL_DUH_PLAYER *dp) DUMB_DEPRECATED;
+DUH_SIGRENDERER *al_duh_decompose_to_renderer(AL_DUH_PLAYER *dp) DUMB_DEPRECATED;
+/* Replace 'renderer' with 'sigrenderer' in each case where you called one of
+ * these functions.
+ */
+
+#endif
+
+
+#ifdef __cplusplus
+	}
+#endif
+
+
+#endif /* ALDUMB_H */
diff -uNr fighterz1/client/aldumb/dumb.h fighterz2/client/aldumb/dumb.h
--- fighterz1/client/aldumb/dumb.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb/dumb.h	2003-04-04 03:32:48.000000000 +0200
@@ -0,0 +1,563 @@
+/*  _______         ____    __         ___    ___
+ * \    _  \       \    /  \  /       \   \  /   /       '   '  '
+ *  |  | \  \       |  |    ||         |   \/   |         .      .
+ *  |  |  |  |      |  |    ||         ||\  /|  |
+ *  |  |  |  |      |  |    ||         || \/ |  |         '  '  '
+ *  |  |  |  |      |  |    ||         ||    |  |         .      .
+ *  |  |_/  /        \  \__//          ||    |  |
+ * /_______/ynamic    \____/niversal  /__\  /____\usic   /|  .  . ibliotheque
+ *                                                      /  \
+ *                                                     / .  \
+ * dumb.h - The user header file for DUMB.            / / \  \
+ *                                                   | <  /   \_
+ * Include this file in any of your files in         |  \/ /\   /
+ * which you wish to use the DUMB functions           \_  /  > /
+ * and variables.                                       | \ / /
+ *                                                      |  ' /
+ *                                                       \__/
+ */
+
+#ifndef DUMB_H
+#define DUMB_H
+
+
+#include <stdlib.h>
+#include <stdio.h>
+
+
+#ifdef __cplusplus
+	extern "C" {
+#endif
+
+
+#define DUMB_MAJOR_VERSION    0
+#define DUMB_MINOR_VERSION    9
+#define DUMB_REVISION_VERSION 2
+
+#define DUMB_VERSION (DUMB_MAJOR_VERSION*10000 + DUMB_MINOR_VERSION*100 + DUMB_REVISION_VERSION)
+
+#define DUMB_VERSION_STR "0.9.2"
+
+#define DUMB_NAME "DUMB v"DUMB_VERSION_STR
+
+#define DUMB_YEAR  2003
+#define DUMB_MONTH 4
+#define DUMB_DAY   2
+
+#define DUMB_YEAR_STR2  "03"
+#define DUMB_YEAR_STR4  "2003"
+#define DUMB_MONTH_STR1 "4"
+#define DUMB_DAY_STR1   "2"
+
+#if DUMB_MONTH < 10
+#define DUMB_MONTH_STR2 "0"DUMB_MONTH_STR1
+#else
+#define DUMB_MONTH_STR2 DUMB_MONTH_STR1
+#endif
+
+#if DUMB_DAY < 10
+#define DUMB_DAY_STR2 "0"DUMB_DAY_STR1
+#else
+#define DUMB_DAY_STR2 DUMB_DAY_STR1
+#endif
+
+
+/* WARNING: The month and day were inadvertently swapped in the v0.8 release.
+ *          Please do not compare this constant against any date in 2002. In
+ *          any case, DUMB_VERSION is probably more useful for this purpose.
+ */
+#define DUMB_DATE (DUMB_YEAR*10000 + DUMB_MONTH*100 + DUMB_DAY)
+
+#define DUMB_DATE_STR DUMB_DAY_STR1"."DUMB_MONTH_STR1"."DUMB_YEAR_STR4
+
+
+#undef MIN
+#undef MAX
+#undef MID
+
+#define MIN(x,y)   (((x) < (y)) ? (x) : (y))
+#define MAX(x,y)   (((x) > (y)) ? (x) : (y))
+#define MID(x,y,z) MAX((x), MIN((y), (z)))
+
+#undef ABS
+#define ABS(x) (((x) >= 0) ? (x) : (-(x)))
+
+
+#ifdef DEBUGMODE
+
+#ifndef ASSERT
+#include <assert.h>
+#define ASSERT(n) assert(n)
+#endif
+#ifndef TRACE
+// it would be nice if this did actually trace ...
+#define TRACE 1 ? (void)0 : (void)printf
+#endif
+
+#else
+
+#ifndef ASSERT
+#define ASSERT(n)
+#endif
+#ifndef TRACE
+#define TRACE 1 ? (void)0 : (void)printf
+#endif
+
+#endif
+
+
+#define DUMB_ID(a,b,c,d) (((unsigned int)(a) << 24) | \
+                          ((unsigned int)(b) << 16) | \
+                          ((unsigned int)(c) <<  8) | \
+                          ((unsigned int)(d)      ))
+
+
+
+#ifndef LONG_LONG
+#ifdef __GNUC__
+#define LONG_LONG long long
+#elif defined _MSC_VER
+#define LONG_LONG __int64
+#else
+#error 64-bit integer type unknown
+#endif
+#endif
+
+#if __GNUC__ * 100 + __GNUC_MINOR__ >= 301 /* GCC 3.1+ */
+#ifndef DUMB_DECLARE_DEPRECATED
+#define DUMB_DECLARE_DEPRECATED
+#endif
+#define DUMB_DEPRECATED __attribute__((__deprecated__))
+#else
+#define DUMB_DEPRECATED
+#endif
+
+
+/* Basic Sample Type. Normal range is -0x800000 to 0x7FFFFF. */
+
+typedef int sample_t;
+
+
+/* Library Clean-up Management */
+
+int dumb_atexit(void (*proc)(void));
+
+void dumb_exit(void);
+
+
+/* File Input Functions */
+
+typedef struct DUMBFILE_SYSTEM
+{
+	void *(*open)(const char *filename);
+	int (*skip)(void *f, long n);
+	int (*getc)(void *f);
+	long (*getnc)(char *ptr, long n, void *f);
+	void (*close)(void *f);
+}
+DUMBFILE_SYSTEM;
+
+typedef struct DUMBFILE DUMBFILE;
+
+void register_dumbfile_system(DUMBFILE_SYSTEM *dfs);
+
+DUMBFILE *dumbfile_open(const char *filename);
+DUMBFILE *dumbfile_open_ex(void *file, DUMBFILE_SYSTEM *dfs);
+
+long dumbfile_pos(DUMBFILE *f);
+int dumbfile_skip(DUMBFILE *f, long n);
+
+int dumbfile_getc(DUMBFILE *f);
+
+int dumbfile_igetw(DUMBFILE *f);
+int dumbfile_mgetw(DUMBFILE *f);
+
+long dumbfile_igetl(DUMBFILE *f);
+long dumbfile_mgetl(DUMBFILE *f);
+
+unsigned long dumbfile_cgetul(DUMBFILE *f);
+signed long dumbfile_cgetsl(DUMBFILE *f);
+
+long dumbfile_getnc(char *ptr, long n, DUMBFILE *f);
+
+int dumbfile_error(DUMBFILE *f);
+int dumbfile_close(DUMBFILE *f);
+
+
+/* stdio File Input Module */
+
+void dumb_register_stdfiles(void);
+
+DUMBFILE *dumbfile_open_stdfile(FILE *p);
+
+
+/* Memory File Input Module */
+
+DUMBFILE *dumbfile_open_memory(const char *data, long size);
+
+
+/* DUH Management */
+
+typedef struct DUH DUH;
+
+#define DUH_SIGNATURE DUMB_ID('D','U','H','!')
+
+void unload_duh(DUH *duh);
+
+DUH *load_duh(const char *filename);
+DUH *read_duh(DUMBFILE *f);
+
+long duh_get_length(DUH *duh);
+
+
+/* Signal Rendering Functions */
+
+typedef struct DUH_SIGRENDERER DUH_SIGRENDERER;
+
+DUH_SIGRENDERER *duh_start_sigrenderer(DUH *duh, int sig, int n_channels, long pos);
+
+#ifdef DUMB_DECLARE_DEPRECATED
+typedef void (*DUH_SIGRENDERER_CALLBACK)(void *data, sample_t **samples, int n_channels, long length);
+/* This is deprecated, but is not marked as such because GCC tends to
+ * complain spuriously when the typedef is used later. See comments below.
+ */
+
+void duh_sigrenderer_set_callback(
+	DUH_SIGRENDERER *sigrenderer,
+	DUH_SIGRENDERER_CALLBACK callback, void *data
+) DUMB_DEPRECATED;
+/* The 'callback' argument's type has changed for const-correctness. See the
+ * DUH_SIGRENDERER_CALLBACK definition just above. Also note that the samples
+ * in the buffer are now 256 times as large; the normal range is -0x800000 to
+ * 0x7FFFFF. The function has been renamed partly because its functionality
+ * has changed slightly and partly so that its name is more meaningful. The
+ * new one is duh_sigrenderer_set_analyser_callback(), and the typedef for
+ * the function pointer has also changed, from DUH_SIGRENDERER_CALLBACK to
+ * DUH_SIGRENDERER_ANALYSER_CALLBACK. (If you wanted to use this callback to
+ * apply a DSP effect, don't worry; there is a better way of doing this. It
+ * is undocumented, so contact me and I shall try to help. Contact details
+ * are in readme.txt.)
+ */
+#endif
+
+typedef void (*DUH_SIGRENDERER_ANALYSER_CALLBACK)(void *data, const sample_t *const *samples, int n_channels, long length);
+
+void duh_sigrenderer_set_analyser_callback(
+	DUH_SIGRENDERER *sigrenderer,
+	DUH_SIGRENDERER_ANALYSER_CALLBACK callback, void *data
+);
+
+int duh_sigrenderer_get_n_channels(DUH_SIGRENDERER *sigrenderer);
+long duh_sigrenderer_get_position(DUH_SIGRENDERER *sigrenderer);
+
+void duh_sigrenderer_set_sigparam(DUH_SIGRENDERER *sigrenderer, unsigned char id, long value);
+
+long duh_sigrenderer_get_samples(
+	DUH_SIGRENDERER *sigrenderer,
+	float volume, float delta,
+	long size, sample_t **samples
+);
+
+void duh_sigrenderer_get_current_sample(DUH_SIGRENDERER *sigrenderer, float volume, sample_t *samples);
+
+void duh_end_sigrenderer(DUH_SIGRENDERER *sigrenderer);
+
+
+/* DUH Rendering Functions */
+
+long duh_render(
+	DUH_SIGRENDERER *sigrenderer,
+	int bits, int unsign,
+	float volume, float delta,
+	long size, void *sptr
+);
+
+#ifdef DUMB_DECLARE_DEPRECATED
+
+long duh_render_signal(
+	DUH_SIGRENDERER *sigrenderer,
+	float volume, float delta,
+	long size, sample_t **samples
+) DUMB_DEPRECATED;
+/* Please use duh_sigrenderer_get_samples(). Arguments and functionality are
+ * identical.
+ */
+
+typedef DUH_SIGRENDERER DUH_RENDERER DUMB_DEPRECATED;
+/* Please use DUH_SIGRENDERER instead of DUH_RENDERER. */
+
+DUH_SIGRENDERER *duh_start_renderer(DUH *duh, int n_channels, long pos) DUMB_DEPRECATED;
+/* Please use duh_start_sigrenderer() instead. Pass 0 for 'sig'. */
+
+int duh_renderer_get_n_channels(DUH_SIGRENDERER *dr) DUMB_DEPRECATED;
+long duh_renderer_get_position(DUH_SIGRENDERER *dr) DUMB_DEPRECATED;
+/* Please use the duh_sigrenderer_*() equivalents of these two functions. */
+
+void duh_end_renderer(DUH_SIGRENDERER *dr) DUMB_DEPRECATED;
+/* Please use duh_end_sigrenderer() instead. */
+
+DUH_SIGRENDERER *duh_renderer_encapsulate_sigrenderer(DUH_SIGRENDERER *sigrenderer) DUMB_DEPRECATED;
+DUH_SIGRENDERER *duh_renderer_get_sigrenderer(DUH_SIGRENDERER *dr) DUMB_DEPRECATED;
+DUH_SIGRENDERER *duh_renderer_decompose_to_sigrenderer(DUH_SIGRENDERER *dr) DUMB_DEPRECATED;
+/* These functions have become no-ops that just return the parameter.
+ * So, for instance, replace
+ *   duh_renderer_encapsulate_sigrenderer(my_sigrenderer)
+ * with
+ *   my_sigrenderer
+ */
+
+#endif
+
+
+/* Impulse Tracker Support */
+
+extern int dumb_it_max_to_mix;
+
+typedef struct DUMB_IT_SIGDATA DUMB_IT_SIGDATA;
+typedef struct DUMB_IT_SIGRENDERER DUMB_IT_SIGRENDERER;
+
+DUMB_IT_SIGDATA *duh_get_it_sigdata(DUH *duh);
+DUH_SIGRENDERER *duh_encapsulate_it_sigrenderer(DUMB_IT_SIGRENDERER *it_sigrenderer, int n_channels, long pos);
+DUMB_IT_SIGRENDERER *duh_get_it_sigrenderer(DUH_SIGRENDERER *sigrenderer);
+
+DUH_SIGRENDERER *dumb_it_start_at_order(DUH *duh, int n_channels, int startorder);
+
+void dumb_it_set_loop_callback(DUMB_IT_SIGRENDERER *sigrenderer, int (*callback)(void *data), void *data);
+void dumb_it_set_xm_speed_zero_callback(DUMB_IT_SIGRENDERER *sigrenderer, int (*callback)(void *data), void *data);
+void dumb_it_set_midi_callback(DUMB_IT_SIGRENDERER *sigrenderer, int (*callback)(void *data, int channel, unsigned char byte), void *data);
+
+int dumb_it_callback_terminate(void *data);
+int dumb_it_callback_midi_block(void *data, int channel, unsigned char byte);
+
+DUH *dumb_load_it(const char *filename);
+DUH *dumb_load_xm(const char *filename);
+DUH *dumb_load_s3m(const char *filename);
+DUH *dumb_load_mod(const char *filename);
+
+DUH *dumb_read_it(DUMBFILE *f);
+DUH *dumb_read_xm(DUMBFILE *f);
+DUH *dumb_read_s3m(DUMBFILE *f);
+DUH *dumb_read_mod(DUMBFILE *f);
+
+int dumb_it_sd_get_n_orders(DUMB_IT_SIGDATA *sd);
+
+int dumb_it_sd_get_initial_global_volume(DUMB_IT_SIGDATA *sd);
+void dumb_it_sd_set_initial_global_volume(DUMB_IT_SIGDATA *sd, int gv);
+
+int dumb_it_sd_get_mixing_volume(DUMB_IT_SIGDATA *sd);
+void dumb_it_sd_set_mixing_volume(DUMB_IT_SIGDATA *sd, int mv);
+
+int dumb_it_sd_get_initial_speed(DUMB_IT_SIGDATA *sd);
+void dumb_it_sd_set_initial_speed(DUMB_IT_SIGDATA *sd, int speed);
+
+int dumb_it_sd_get_initial_tempo(DUMB_IT_SIGDATA *sd);
+void dumb_it_sd_set_initial_tempo(DUMB_IT_SIGDATA *sd, int tempo);
+
+int dumb_it_sd_get_initial_channel_volume(DUMB_IT_SIGDATA *sd, int channel);
+void dumb_it_sd_set_initial_channel_volume(DUMB_IT_SIGDATA *sd, int channel, int volume);
+
+int dumb_it_sr_get_current_order(DUMB_IT_SIGRENDERER *sr);
+int dumb_it_sr_get_current_row(DUMB_IT_SIGRENDERER *sr);
+
+int dumb_it_sr_get_global_volume(DUMB_IT_SIGRENDERER *sr);
+void dumb_it_sr_set_global_volume(DUMB_IT_SIGRENDERER *sr, int gv);
+
+int dumb_it_sr_get_tempo(DUMB_IT_SIGRENDERER *sr);
+void dumb_it_sr_set_tempo(DUMB_IT_SIGRENDERER *sr, int tempo);
+
+int dumb_it_sr_get_speed(DUMB_IT_SIGRENDERER *sr);
+void dumb_it_sr_set_speed(DUMB_IT_SIGRENDERER *sr, int speed);
+
+#define DUMB_IT_N_CHANNELS 64
+#define DUMB_IT_N_NNA_CHANNELS 192
+#define DUMB_IT_TOTAL_CHANNELS (DUMB_IT_N_CHANNELS + DUMB_IT_N_NNA_CHANNELS)
+
+/* Channels passed to any of these functions are 0-based */
+int dumb_it_sr_get_channel_volume(DUMB_IT_SIGRENDERER *sr, int channel);
+void dumb_it_sr_set_channel_volume(DUMB_IT_SIGRENDERER *sr, int channel, int volume);
+
+typedef struct DUMB_IT_CHANNEL_STATE DUMB_IT_CHANNEL_STATE;
+
+struct DUMB_IT_CHANNEL_STATE
+{
+	int channel; /* 0-based; meaningful for NNA channels */
+	int sample; /* 1-based; 0 if nothing playing, then other fields undef */
+	int freq; /* in Hz */
+	float volume; /* 1.0 maximum; affected by ALL factors, inc. mixing vol */
+	unsigned char pan; /* 0-64, 100 for surround */
+	signed char subpan; /* use (pan + subpan/256.0f) or ((pan<<8)+subpan) */
+	unsigned char filter_cutoff;    /* 0-127    cutoff=127 AND resonance=0 */
+	unsigned char filter_subcutoff; /* 0-255      -> no filters (subcutoff */
+	unsigned char filter_resonance; /* 0-127        always 0 in this case) */
+	/* subcutoff only changes from zero if filter envelopes are in use. The
+	 * calculation (filter_cutoff + filter_subcutoff/256.0f) gives a more
+	 * accurate filter cutoff measurement as a float. It would often be more
+	 * useful to use a scaled int such as ((cutoff<<8) + subcutoff).
+	 */
+};
+
+/* Values of 64 or more will access NNA channels here. */
+void dumb_it_sr_get_channel_state(DUMB_IT_SIGRENDERER *sr, int channel, DUMB_IT_CHANNEL_STATE *state);
+
+
+/* Signal Design Helper Values */
+
+/* Use pow(DUMB_SEMITONE_BASE, n) to get the 'delta' value to transpose up by
+ * n semitones. To transpose down, use negative n.
+ */
+#define DUMB_SEMITONE_BASE 1.059463094359295309843105314939748495817
+
+/* Use pow(DUMB_QUARTERTONE_BASE, n) to get the 'delta' value to transpose up
+ * by n quartertones. To transpose down, use negative n.
+ */
+#define DUMB_QUARTERTONE_BASE 1.029302236643492074463779317738953977823
+
+/* Use pow(DUMB_PITCH_BASE, n) to get the 'delta' value to transpose up by n
+ * units. In this case, 256 units represent one semitone; 3072 units
+ * represent one octave. These units are used by the sequence signal (SEQU).
+ */
+#define DUMB_PITCH_BASE 1.000225659305069791926712241547647863626
+
+
+/* Signal Design Function Types */
+
+typedef void sigdata_t;
+typedef void sigrenderer_t;
+
+typedef sigdata_t *(*DUH_LOAD_SIGDATA)(DUH *duh, DUMBFILE *file);
+
+typedef sigrenderer_t *(*DUH_START_SIGRENDERER)(
+	DUH *duh,
+	sigdata_t *sigdata,
+	int n_channels,
+	long pos
+);
+
+typedef void (*DUH_SIGRENDERER_SET_SIGPARAM)(
+	sigrenderer_t *sigrenderer,
+	unsigned char id, long value
+);
+
+typedef long (*DUH_SIGRENDERER_GET_SAMPLES)(
+	sigrenderer_t *sigrenderer,
+	float volume, float delta,
+	long size, sample_t **samples
+);
+
+typedef void (*DUH_SIGRENDERER_GET_CURRENT_SAMPLE)(
+	sigrenderer_t *sigrenderer,
+	float volume,
+	sample_t *samples
+);
+
+typedef void (*DUH_END_SIGRENDERER)(sigrenderer_t *sigrenderer);
+
+typedef void (*DUH_UNLOAD_SIGDATA)(sigdata_t *sigdata);
+
+
+/* Signal Design Function Registration */
+
+typedef struct DUH_SIGTYPE_DESC
+{
+	long type;
+	DUH_LOAD_SIGDATA                   load_sigdata;
+	DUH_START_SIGRENDERER              start_sigrenderer;
+	DUH_SIGRENDERER_SET_SIGPARAM       sigrenderer_set_sigparam;
+	DUH_SIGRENDERER_GET_SAMPLES        sigrenderer_get_samples;
+	DUH_SIGRENDERER_GET_CURRENT_SAMPLE sigrenderer_get_current_sample;
+	DUH_END_SIGRENDERER                end_sigrenderer;
+	DUH_UNLOAD_SIGDATA                 unload_sigdata;
+}
+DUH_SIGTYPE_DESC;
+
+void dumb_register_sigtype(DUH_SIGTYPE_DESC *desc);
+
+
+// Decide where to put these functions; new heading?
+
+sigdata_t *duh_get_raw_sigdata(DUH *duh, int sig, long type);
+
+DUH_SIGRENDERER *duh_encapsulate_raw_sigrenderer(sigrenderer_t *vsigrenderer, DUH_SIGTYPE_DESC *desc, int n_channels, long pos);
+sigrenderer_t *duh_get_raw_sigrenderer(DUH_SIGRENDERER *sigrenderer, long type);
+
+
+/* Sample Buffer Allocation Helpers */
+
+sample_t **create_sample_buffer(int n_channels, long length);
+void destroy_sample_buffer(sample_t **samples);
+
+
+/* Silencing Helper */
+
+void dumb_silence(sample_t *samples, long length);
+
+
+/* Click Removal Helpers */
+
+typedef struct DUMB_CLICK_REMOVER DUMB_CLICK_REMOVER;
+
+DUMB_CLICK_REMOVER *dumb_create_click_remover(void);
+void dumb_record_click(DUMB_CLICK_REMOVER *cr, long pos, sample_t step);
+void dumb_remove_clicks(DUMB_CLICK_REMOVER *cr, sample_t *samples, long length, float halflife);
+sample_t dumb_click_remover_get_offset(DUMB_CLICK_REMOVER *cr);
+void dumb_destroy_click_remover(DUMB_CLICK_REMOVER *cr);
+
+DUMB_CLICK_REMOVER **dumb_create_click_remover_array(int n);
+void dumb_record_click_array(int n, DUMB_CLICK_REMOVER **cr, long pos, sample_t *step);
+void dumb_record_click_negative_array(int n, DUMB_CLICK_REMOVER **cr, long pos, sample_t *step);
+void dumb_remove_clicks_array(int n, DUMB_CLICK_REMOVER **cr, sample_t **samples, long length, float halflife);
+void dumb_click_remover_get_offset_array(int n, DUMB_CLICK_REMOVER **cr, sample_t *offset);
+void dumb_destroy_click_remover_array(int n, DUMB_CLICK_REMOVER **cr);
+
+
+/* Resampling Helpers */
+
+#define DUMB_RQ_ALIASING 0
+#define DUMB_RQ_LINEAR   1
+#define DUMB_RQ_CUBIC    2
+#define DUMB_RQ_N_LEVELS 3
+extern int dumb_resampling_quality;
+
+typedef struct DUMB_RESAMPLER DUMB_RESAMPLER;
+
+typedef void (*DUMB_RESAMPLE_PICKUP)(DUMB_RESAMPLER *resampler, void *data);
+
+struct DUMB_RESAMPLER
+{
+	sample_t *src;
+	long pos;
+	int subpos;
+	long start, end;
+	int dir;
+	DUMB_RESAMPLE_PICKUP pickup;
+	void *pickup_data;
+	int min_quality;
+	int max_quality;
+	/* Everything below this point is internal: do not use. */
+	sample_t x[3];
+	int overshot;
+};
+
+void dumb_reset_resampler(DUMB_RESAMPLER *resampler, sample_t *src, long pos, long start, long end);
+DUMB_RESAMPLER *dumb_start_resampler(sample_t *src, long pos, long start, long end);
+long dumb_resample(DUMB_RESAMPLER *resampler, sample_t *dst, long dst_size, float volume, float delta);
+sample_t dumb_resample_get_current_sample(DUMB_RESAMPLER *resampler, float volume);
+void dumb_end_resampler(DUMB_RESAMPLER *resampler);
+
+
+/* DUH Construction */
+
+DUH *make_duh(
+	long length,
+	int n_signals,
+	DUH_SIGTYPE_DESC *desc[],
+	sigdata_t *sigdata[]
+);
+
+
+#ifdef __cplusplus
+	}
+#endif
+
+
+#endif /* DUMB_H */
diff -uNr fighterz1/client/aldumb/internal/aldumb.h fighterz2/client/aldumb/internal/aldumb.h
--- fighterz1/client/aldumb/internal/aldumb.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb/internal/aldumb.h	2003-04-04 03:32:48.000000000 +0200
@@ -0,0 +1,27 @@
+/*  _______         ____    __         ___    ___
+ * \    _  \       \    /  \  /       \   \  /   /       '   '  '
+ *  |  | \  \       |  |    ||         |   \/   |         .      .
+ *  |  |  |  |      |  |    ||         ||\  /|  |
+ *  |  |  |  |      |  |    ||         || \/ |  |         '  '  '
+ *  |  |  |  |      |  |    ||         ||    |  |         .      .
+ *  |  |_/  /        \  \__//          ||    |  |
+ * /_______/ynamic    \____/niversal  /__\  /____\usic   /|  .  . ibliotheque
+ *                                                      /  \
+ *                                                     / .  \
+ * internal/aldumb.h - The internal header file       / / \  \
+ *                     for DUMB with Allegro.        | <  /   \_
+ *                                                   |  \/ /\   /
+ *                                                    \_  /  > /
+ *                                                      | \ / /
+ *                                                      |  ' /
+ *                                                       \__/
+ */
+
+#ifndef INTERNAL_ALDUMB_H
+#define INTERNAL_ALDUMB_H
+
+
+void _dat_unload_duh(void *duh);
+
+
+#endif /* INTERNAL_DUMB_H */
diff -uNr fighterz1/client/aldumb/internal/dumb.h fighterz2/client/aldumb/internal/dumb.h
--- fighterz1/client/aldumb/internal/dumb.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb/internal/dumb.h	2003-04-04 03:32:48.000000000 +0200
@@ -0,0 +1,58 @@
+/*  _______         ____    __         ___    ___
+ * \    _  \       \    /  \  /       \   \  /   /       '   '  '
+ *  |  | \  \       |  |    ||         |   \/   |         .      .
+ *  |  |  |  |      |  |    ||         ||\  /|  |
+ *  |  |  |  |      |  |    ||         || \/ |  |         '  '  '
+ *  |  |  |  |      |  |    ||         ||    |  |         .      .
+ *  |  |_/  /        \  \__//          ||    |  |
+ * /_______/ynamic    \____/niversal  /__\  /____\usic   /|  .  . ibliotheque
+ *                                                      /  \
+ *                                                     / .  \
+ * internal/dumb.h - DUMB's internal declarations.    / / \  \
+ *                                                   | <  /   \_
+ * This header file provides access to the           |  \/ /\   /
+ * internal structure of DUMB, and is liable          \_  /  > /
+ * to change, mutate or cease to exist at any           | \ / /
+ * moment. Include it at your own peril.                |  ' /
+ *                                                       \__/
+ * ...
+ *
+ * I mean it, people. You don't need access to anything in this file. If you
+ * disagree, contact the authors. In the unlikely event that you make a good
+ * case, we'll add what you need to dumb.h. Thanking you kindly.
+ */
+
+#ifndef INTERNAL_DUMB_H
+#define INTERNAL_DUMB_H
+
+
+typedef struct DUH_SIGTYPE_DESC_LINK
+{
+	struct DUH_SIGTYPE_DESC_LINK *next;
+	DUH_SIGTYPE_DESC *desc;
+}
+DUH_SIGTYPE_DESC_LINK;
+
+
+typedef struct DUH_SIGNAL
+{
+	sigdata_t *sigdata;
+	DUH_SIGTYPE_DESC *desc;
+}
+DUH_SIGNAL;
+
+
+struct DUH
+{
+	long length;
+
+	int n_signals;
+	DUH_SIGNAL **signal;
+};
+
+
+DUH_SIGTYPE_DESC *_dumb_get_sigtype_desc(long type);
+
+
+#endif /* INTERNAL_DUMB_H */
+
diff -uNr fighterz1/client/aldumb/internal/it.h fighterz2/client/aldumb/internal/it.h
--- fighterz1/client/aldumb/internal/it.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb/internal/it.h	2003-04-04 03:32:48.000000000 +0200
@@ -0,0 +1,710 @@
+/*  _______         ____    __         ___    ___
+ * \    _  \       \    /  \  /       \   \  /   /       '   '  '
+ *  |  | \  \       |  |    ||         |   \/   |         .      .
+ *  |  |  |  |      |  |    ||         ||\  /|  |
+ *  |  |  |  |      |  |    ||         || \/ |  |         '  '  '
+ *  |  |  |  |      |  |    ||         ||    |  |         .      .
+ *  |  |_/  /        \  \__//          ||    |  |
+ * /_______/ynamic    \____/niversal  /__\  /____\usic   /|  .  . ibliotheque
+ *                                                      /  \
+ *                                                     / .  \
+ * internal/it.h - Internal stuff for IT playback     / / \  \
+ *                 and MOD/XM/S3M conversion.        | <  /   \_
+ *                                                   |  \/ /\   /
+ *                                                    \_  /  > /
+ *                                                      | \ / /
+ *                                                      |  ' /
+ *                                                       \__/
+ */
+
+#ifndef INTERNAL_IT_H
+#define INTERNAL_IT_H
+
+
+
+#include <stddef.h>
+
+
+
+/** TO DO: THINK ABOUT THE FOLLOWING:
+
+sigdata->flags & IT_COMPATIBLE_GXX
+
+                Bit 5: On = Link Effect G's memory with Effect E/F. Also
+                            Gxx with an instrument present will cause the
+                            envelopes to be retriggered. If you change a
+                            sample on a row with Gxx, it'll adjust the
+                            frequency of the current note according to:
+
+                              NewFrequency = OldFrequency * NewC5 / OldC5;
+*/
+
+
+
+/* These #defines are TEMPORARY. They are used to write alternative code to
+ * handle ambiguities in the format specification. The correct code in each
+ * case will be determined most likely by experimentation.
+ */
+#define STEREO_SAMPLES_COUNT_AS_TWO
+#define INVALID_ORDERS_END_SONG
+#define INVALID_NOTES_CAUSE_NOTE_CUT
+#define SUSTAIN_LOOP_OVERRIDES_NORMAL_LOOP
+#define VOLUME_OUT_OF_RANGE_SETS_MAXIMUM
+
+
+
+#define SIGTYPE_IT DUMB_ID('I', 'T', ' ', ' ')
+
+#define IT_SIGNATURE            DUMB_ID('I', 'M', 'P', 'M')
+#define IT_INSTRUMENT_SIGNATURE DUMB_ID('I', 'M', 'P', 'I')
+#define IT_SAMPLE_SIGNATURE     DUMB_ID('I', 'M', 'P', 'S')
+
+
+
+/* 1 minute per 4 rows, each row 6 ticks; this is divided by the tempo to get
+ * the interval between ticks.
+ */
+#define TICK_TIME_DIVIDEND ((65536 * 60) / (4 * 6))
+
+
+
+/* I'm not going to try to explain this, because I didn't derive it very
+ * formally ;)
+ */
+/* #define AMIGA_DIVISOR ((float)(4.0 * 14317056.0)) */
+/* I believe the following one to be more accurate. */
+#define AMIGA_DIVISOR ((float)(8.0 * 7159090.5))
+
+
+
+typedef struct IT_MIDI IT_MIDI;
+typedef struct IT_FILTER_STATE IT_FILTER_STATE;
+typedef struct IT_ENVELOPE IT_ENVELOPE;
+typedef struct IT_INSTRUMENT IT_INSTRUMENT;
+typedef struct IT_SAMPLE IT_SAMPLE;
+typedef struct IT_ENTRY IT_ENTRY;
+typedef struct IT_PATTERN IT_PATTERN;
+typedef struct IT_PLAYING_ENVELOPE IT_PLAYING_ENVELOPE;
+typedef struct IT_PLAYING IT_PLAYING;
+typedef struct IT_CHANNEL IT_CHANNEL;
+typedef struct IT_CHECKPOINT IT_CHECKPOINT;
+typedef struct IT_CALLBACKS IT_CALLBACKS;
+
+
+
+struct IT_MIDI
+{
+	unsigned char SFmacro[16][16]; // read these from 0x120
+	unsigned char SFmacrolen[16];
+	unsigned short SFmacroz[16]; /* Bitfield; bit 0 set = z in first position */
+	unsigned char Zmacro[128][16]; // read these from 0x320
+	unsigned char Zmacrolen[128];
+};
+
+
+
+struct IT_FILTER_STATE
+{
+	float currsample, prevsample;
+};
+
+
+
+#define IT_ENVELOPE_ON                1
+#define IT_ENVELOPE_LOOP_ON           2
+#define IT_ENVELOPE_SUSTAIN_LOOP      4
+#define IT_ENVELOPE_PITCH_IS_FILTER 128
+
+struct IT_ENVELOPE
+{
+	unsigned char flags;
+	unsigned char n_nodes;
+	unsigned char loop_start;
+	unsigned char loop_end;
+	unsigned char sus_loop_start;
+	unsigned char sus_loop_end;
+	signed char node_y[25];
+	unsigned short node_t[25];
+};
+
+
+
+#define NNA_NOTE_CUT      0
+#define NNA_NOTE_CONTINUE 1
+#define NNA_NOTE_OFF      2
+#define NNA_NOTE_FADE     3
+
+#define DCT_OFF        0
+#define DCT_NOTE       1
+#define DCT_SAMPLE     2
+#define DCT_INSTRUMENT 3
+
+#define DCA_NOTE_CUT  0
+#define DCA_NOTE_OFF  1
+#define DCA_NOTE_FADE 2
+
+struct IT_INSTRUMENT
+{
+	int fadeout;
+
+	IT_ENVELOPE volume_envelope;
+	IT_ENVELOPE pan_envelope;
+	IT_ENVELOPE pitch_envelope;
+
+	unsigned char new_note_action;
+	unsigned char dup_check_type;
+	unsigned char dup_check_action;
+	unsigned char pp_separation;
+	unsigned char pp_centre;
+	unsigned char global_volume;
+	unsigned char default_pan;
+	unsigned char random_volume;
+	unsigned char random_pan;
+
+	unsigned char filter_cutoff;
+	unsigned char filter_resonance;
+
+	unsigned char map_note[120];
+	unsigned short map_sample[120];
+};
+
+
+
+#define IT_SAMPLE_EXISTS              1
+#define IT_SAMPLE_16BIT               2
+#define IT_SAMPLE_STEREO              4
+#define IT_SAMPLE_LOOP               16
+#define IT_SAMPLE_SUS_LOOP           32
+#define IT_SAMPLE_PINGPONG_LOOP      64
+#define IT_SAMPLE_PINGPONG_SUS_LOOP 128
+
+#define IT_VIBRATO_SINE     0
+#define IT_VIBRATO_SAWTOOTH 1 /* Ramp down */
+#define IT_VIBRATO_SQUARE   2
+#define IT_VIBRATO_RANDOM   3
+
+struct IT_SAMPLE
+{
+	unsigned char flags;
+	unsigned char global_volume;
+	unsigned char default_volume;
+	unsigned char default_pan;
+
+	long length;
+	long loop_start;
+	long loop_end;
+	long C5_speed;
+	long sus_loop_start;
+	long sus_loop_end;
+
+	unsigned char vibrato_speed;
+	unsigned char vibrato_depth;
+	unsigned char vibrato_rate;
+	unsigned char vibrato_waveform;
+
+	sample_t *left;
+	sample_t *right;
+};
+
+
+
+#define IT_ENTRY_NOTE       1
+#define IT_ENTRY_INSTRUMENT 2
+#define IT_ENTRY_VOLPAN     4
+#define IT_ENTRY_EFFECT     8
+
+#define IT_SET_END_ROW(entry) ((entry)->channel = 255)
+#define IT_IS_END_ROW(entry) ((entry)->channel >= DUMB_IT_N_CHANNELS)
+
+#define IT_NOTE_OFF 255
+#define IT_NOTE_CUT 254
+
+#define IT_ENVELOPE_SHIFT 8
+
+#define IT_SURROUND 100
+#define IT_IS_SURROUND(pan) ((pan) > 64)
+#define IT_IS_SURROUND_SHIFTED(pan) ((pan) > 64 << IT_ENVELOPE_SHIFT)
+
+#define IT_SET_SPEED              1
+#define IT_JUMP_TO_ORDER          2
+#define IT_BREAK_TO_ROW           3
+#define IT_VOLUME_SLIDE           4
+#define IT_PORTAMENTO_DOWN        5
+#define IT_PORTAMENTO_UP          6
+#define IT_TONE_PORTAMENTO        7
+#define IT_VIBRATO                8
+#define IT_TREMOR                 9
+#define IT_ARPEGGIO              10
+#define IT_VOLSLIDE_VIBRATO      11
+#define IT_VOLSLIDE_TONEPORTA    12
+#define IT_SET_CHANNEL_VOLUME    13
+#define IT_CHANNEL_VOLUME_SLIDE  14
+#define IT_SET_SAMPLE_OFFSET     15
+#define IT_PANNING_SLIDE         16
+#define IT_RETRIGGER_NOTE        17
+#define IT_TREMOLO               18
+#define IT_S                     19
+#define IT_SET_SONG_TEMPO        20
+#define IT_FINE_VIBRATO          21
+#define IT_SET_GLOBAL_VOLUME     22
+#define IT_GLOBAL_VOLUME_SLIDE   23
+#define IT_SET_PANNING           24
+#define IT_PANBRELLO             25
+#define IT_MIDI_MACRO            26 //see MIDI.TXT
+
+/* Some effects needed for XM compatibility */
+#define IT_XM_PORTAMENTO_DOWN    27
+#define IT_XM_PORTAMENTO_UP      28
+#define IT_XM_FINE_VOLSLIDE_DOWN 29
+#define IT_XM_FINE_VOLSLIDE_UP   30
+#define IT_XM_RETRIGGER_NOTE     31
+
+#define IT_N_EFFECTS             32
+
+/* These represent the top nibble of the command value. */
+#define IT_S_SET_FILTER              0 /* Greyed out in IT... */
+#define IT_S_SET_GLISSANDO_CONTROL   1 /* Greyed out in IT... */
+#define IT_S_FINETUNE                2 /* Greyed out in IT... */
+#define IT_S_SET_VIBRATO_WAVEFORM    3
+#define IT_S_SET_TREMOLO_WAVEFORM    4
+#define IT_S_SET_PANBRELLO_WAVEFORM  5
+#define IT_S_FINE_PATTERN_DELAY      6
+#define IT_S7                        7
+#define IT_S_SET_PAN                 8
+#define IT_S_SET_SURROUND_SOUND      9
+#define IT_S_SET_HIGH_OFFSET        10
+#define IT_S_PATTERN_LOOP           11
+#define IT_S_DELAYED_NOTE_CUT       12
+#define IT_S_NOTE_DELAY             13
+#define IT_S_PATTERN_DELAY          14
+#define IT_S_SET_MIDI_MACRO         15
+
+/*
+S0x Set filter
+S1x Set glissando control
+S2x Set finetune
+
+
+S3x Set vibrato waveform to type x
+S4x Set tremelo waveform to type x
+S5x Set panbrello waveform to type x
+  Waveforms for commands S3x, S4x and S5x:
+    0: Sine wave
+    1: Ramp down
+    2: Square wave
+    3: Random wave
+S6x Pattern delay for x ticks
+S70 Past note cut
+S71 Past note off
+S72 Past note fade
+S73 Set NNA to note cut
+S74 Set NNA to continue
+S75 Set NNA to note off
+S76 Set NNA to note fade
+S77 Turn off volume envelope
+S78 Turn on volume envelope
+S79 Turn off panning envelope
+S7A Turn on panning envelope
+S7B Turn off pitch envelope
+S7C Turn on pitch envelope
+S8x Set panning position
+S91 Set surround sound
+SAy Set high value of sample offset yxx00h
+SB0 Set loopback point
+SBx Loop x times to loopback point
+SCx Note cut after x ticks
+SDx Note delay for x ticks
+SEx Pattern delay for x rows
+SFx Set parameterised MIDI Macro
+*/
+
+struct IT_ENTRY
+{
+	unsigned char channel; /* End of row if channel >= DUMB_IT_N_CHANNELS */
+	unsigned char mask;
+	unsigned char note;
+	unsigned char instrument;
+	unsigned char volpan;
+	unsigned char effect;
+	unsigned char effectvalue;
+};
+
+
+
+struct IT_PATTERN
+{
+	int n_rows;
+	int n_entries;
+	IT_ENTRY *entry;
+};
+
+
+
+#define IT_STEREO            1
+#define IT_USE_INSTRUMENTS   4
+#define IT_LINEAR_SLIDES     8 /* If not set, use Amiga slides */
+#define IT_OLD_EFFECTS      16
+#define IT_COMPATIBLE_GXX   32
+
+/* Make sure IT_WAS_AN_XM and IT_WAS_A_MOD aren't set accidentally */
+#define IT_REAL_FLAGS       63
+
+#define IT_WAS_AN_XM        64 /* Set for both XMs and MODs */
+#define IT_WAS_A_MOD       128
+
+#define IT_ORDER_END  255
+#define IT_ORDER_SKIP 254
+
+struct DUMB_IT_SIGDATA
+{
+	int n_orders;
+	int n_instruments;
+	int n_samples;
+	int n_patterns;
+
+	int flags;
+
+	int global_volume;
+	int mixing_volume;
+	int speed;
+	int tempo;
+	int pan_separation;
+
+	unsigned char channel_pan[DUMB_IT_N_CHANNELS];
+	unsigned char channel_volume[DUMB_IT_N_CHANNELS];
+
+	unsigned char *order;
+	unsigned char restart_position; /* for XM compatiblity */
+
+	IT_INSTRUMENT *instrument;
+	IT_SAMPLE *sample;
+	IT_PATTERN *pattern;
+
+	IT_MIDI *midi;
+
+	IT_CHECKPOINT *checkpoint;
+};
+
+
+
+struct IT_PLAYING_ENVELOPE
+{
+	int next_node;
+	int tick;
+};
+
+
+
+#define IT_PLAYING_BACKGROUND 1
+#define IT_PLAYING_SUSTAINOFF 2
+#define IT_PLAYING_FADING     4
+#define IT_PLAYING_DEAD       8
+
+struct IT_PLAYING
+{
+	int flags;
+
+	IT_CHANNEL *channel;
+	IT_SAMPLE *sample;
+	IT_INSTRUMENT *instrument;
+	IT_INSTRUMENT *env_instrument;
+
+	unsigned short sampnum;
+	unsigned char instnum;
+
+	unsigned char channel_volume;
+
+	unsigned char volume;
+	unsigned short pan;
+
+	unsigned char note;
+
+	unsigned char filter_cutoff;
+	unsigned char filter_resonance;
+
+	unsigned short true_filter_cutoff;   /* These incorporate the filter envelope, and will not */
+	unsigned char true_filter_resonance; /* be changed if they would be set to 127<<8 and 0.    */
+
+	unsigned char vibrato_speed;
+	unsigned char vibrato_depth;
+	unsigned char vibrato_n; /* May be specified twice: volpan & effect. */
+	unsigned char vibrato_time;
+
+	unsigned char tremolo_speed;
+	unsigned char tremolo_depth;
+	unsigned char tremolo_time;
+
+	unsigned char sample_vibrato_time;
+	int sample_vibrato_depth; /* Starts at rate?0:depth, increases by rate */
+
+	int slide;
+	float delta;
+
+	IT_PLAYING_ENVELOPE volume_envelope;
+	IT_PLAYING_ENVELOPE pan_envelope;
+	IT_PLAYING_ENVELOPE pitch_envelope;
+
+	int fadeoutcount;
+
+	IT_FILTER_STATE filter_state[2]; /* Left and right */
+
+	DUMB_RESAMPLER resampler[2];
+
+	/* time_lost is used to emulate Impulse Tracker's sample looping
+	 * characteristics. When time_lost is added to pos, the result represents
+	 * the position in the theoretical version of the sample where all loops
+	 * have been expanded. If this is stored, the resampling helpers will
+	 * safely convert it for use with new loop boundaries. The situation is
+	 * slightly more complicated if dir == -1 when the change takes place; we
+	 * must reflect pos off the loop end point and set dir to 1 before
+	 * proceeding.
+	 */
+	long time_lost;
+};
+
+
+
+#define IT_CHANNEL_MUTED 1
+
+struct IT_CHANNEL
+{
+	int flags;
+
+	unsigned char volume;
+	signed char volslide;
+	signed char xm_volslide;
+
+	/* xm_volslide is used for volume slides done in the volume column in an
+	 * XM file, since it seems the volume column slide is applied first,
+	 * followed by clamping, followed by the effects column slide. IT does
+	 * not exhibit this behaviour, so xm_volslide is maintained at zero.
+	 */
+
+	unsigned char pan;
+	unsigned short truepan;
+
+	unsigned char channelvolume;
+	signed char channelvolslide;
+
+	unsigned char instrument;
+	unsigned char note;
+
+	unsigned char SFmacro;
+
+	unsigned char filter_cutoff;
+	unsigned char filter_resonance;
+
+	unsigned char note_cut_count;
+	unsigned char note_delay_count;
+	IT_ENTRY *note_delay_entry;
+
+	int arpeggio;
+	unsigned char retrig;
+	unsigned char xm_retrig;
+	int retrig_tick;
+
+	unsigned char tremor;
+	unsigned char tremor_time; /* Bit 6 set if note on; bit 7 set if tremor active. */
+
+	int portamento;
+	int toneporta;
+	unsigned char destnote;
+
+	/** WARNING - for neatness, should one or both of these be in the IT_PLAYING struct? */
+	unsigned short sample;
+	unsigned char truenote;
+
+	unsigned char midi_state;
+
+	signed char lastvolslide;
+	unsigned char lastDKL;
+	unsigned char lastEF; /* Doubles as last portamento up for XM files */
+	unsigned char lastG;
+	unsigned char lastHspeed;
+	unsigned char lastHdepth;
+	unsigned char lastRspeed;
+	unsigned char lastRdepth;
+	unsigned char lastI;
+	unsigned char lastJ; /* Doubles as last portamento down for XM files */
+	unsigned char lastN;
+	unsigned char lastO;
+	unsigned char high_offset;
+	unsigned char lastQ;
+	unsigned char lastS;
+	unsigned char pat_loop_row;
+	unsigned char pat_loop_count;
+	unsigned char lastW;
+
+	unsigned char xm_lastE1;
+	unsigned char xm_lastE2;
+	unsigned char xm_lastEA;
+	unsigned char xm_lastEB;
+	unsigned char xm_lastX1;
+	unsigned char xm_lastX2;
+
+	IT_PLAYING *playing;
+};
+
+
+
+struct DUMB_IT_SIGRENDERER
+{
+	DUMB_IT_SIGDATA *sigdata;
+
+	int n_channels;
+
+	unsigned char globalvolume;
+	signed char globalvolslide;
+
+	unsigned char tempo;
+	signed char temposlide;
+
+	IT_CHANNEL channel[DUMB_IT_N_CHANNELS];
+
+	IT_PLAYING *playing[DUMB_IT_N_NNA_CHANNELS];
+
+	int tick;
+	int speed;
+	int rowcount;
+
+	int order; /* Set to -1 if the song is terminated by a callback. */
+	int row;
+	int processorder;
+	int processrow;
+	int breakrow;
+	int pat_loop_row;
+
+	int n_rows;
+
+	IT_ENTRY *entry_start;
+	IT_ENTRY *entry;
+	IT_ENTRY *entry_end;
+
+	long time_left; /* Time before the next tick is processed */
+	int sub_time_left;
+
+	DUMB_CLICK_REMOVER **click_remover;
+
+	IT_CALLBACKS *callbacks;
+};
+
+
+
+struct IT_CHECKPOINT
+{
+	IT_CHECKPOINT *next;
+	long time;
+	DUMB_IT_SIGRENDERER *sigrenderer;
+};
+
+
+
+struct IT_CALLBACKS
+{
+	int (*loop)(void *data);
+	void *loop_data;
+	/* Return 1 to prevent looping; the music will terminate abruptly. If you
+	 * want to make the music stop but allow samples to fade (beware, as they
+	 * might not fade at all!), use dumb_it_sr_set_speed() and set the speed
+	 * to 0. Note that xm_speed_zero() will not be called if you set the
+	 * speed manually, and also that this will work for IT and S3M files even
+	 * though the music can't stop in this way by itself.
+	 */
+
+	int (*xm_speed_zero)(void *data);
+	void *xm_speed_zero_data;
+	/* Return 1 to terminate the mod, without letting samples fade. */
+
+	int (*midi)(void *data, int channel, unsigned char byte);
+	void *midi_data;
+	/* Return 1 to prevent DUMB from subsequently interpreting the MIDI bytes
+	 * itself. In other words, return 1 if the Zxx macros in an IT file are
+	 * controlling filters and shouldn't be.
+	 */
+};
+
+
+
+void _dumb_it_end_sigrenderer(sigrenderer_t *sigrenderer);
+void _dumb_it_unload_sigdata(sigdata_t *vsigdata);
+
+extern DUH_SIGTYPE_DESC _dumb_sigtype_it;
+
+
+
+long _dumb_it_build_checkpoints(DUMB_IT_SIGDATA *sigdata);
+
+
+
+#define XM_APPREGIO                0
+#define XM_PORTAMENTO_UP           1
+#define XM_PORTAMENTO_DOWN         2
+#define XM_TONE_PORTAMENTO         3
+#define XM_VIBRATO                 4
+#define XM_VOLSLIDE_TONEPORTA      5
+#define XM_VOLSLIDE_VIBRATO        6
+#define XM_TREMOLO                 7
+#define XM_SET_PANNING             8
+#define XM_SAMPLE_OFFSET           9
+#define XM_VOLUME_SLIDE            10 /* A */
+#define XM_POSITION_JUMP           11 /* B */
+#define XM_SET_CHANNEL_VOLUME      12 /* C */
+#define XM_PATTERN_BREAK           13 /* D */
+#define XM_E                       14 /* E */
+#define XM_SET_TEMPO_BPM           15 /* F */
+#define XM_SET_GLOBAL_VOLUME       16 /* G */
+#define XM_GLOBAL_VOLUME_SLIDE     17 /* H */
+#define XM_KEY_OFF                 20 /* K (undocumented) */
+#define XM_SET_ENVELOPE_POSITION   21 /* L */
+#define XM_PANNING_SLIDE           25 /* P */
+#define XM_MULTI_RETRIG            27 /* R */
+#define XM_TREMOR                  29 /* T */
+#define XM_X                       33 /* X */
+#define XM_N_EFFECTS               (10+26)
+
+#define XM_E_SET_FILTER            0x0
+#define XM_E_FINE_PORTA_UP         0x1
+#define XM_E_FINE_PORTA_DOWN       0x2
+#define XM_E_SET_GLISSANDO_CONTROL 0x3
+#define XM_E_SET_VIBRATO_CONTROL   0x4
+#define XM_E_SET_FINETUNE          0x5
+#define XM_E_SET_LOOP              0x6
+#define XM_E_SET_TREMOLO_CONTROL   0x7
+#define XM_E_RETRIG_NOTE           0x9
+#define XM_E_FINE_VOLSLIDE_UP      0xA
+#define XM_E_FINE_VOLSLIDE_DOWN    0xB
+#define XM_E_NOTE_CUT              0xC
+#define XM_E_NOTE_DELAY            0xD
+#define XM_E_PATTERN_DELAY         0xE
+
+#define XM_X_EXTRAFINE_PORTA_UP    1
+#define XM_X_EXTRAFINE_PORTA_DOWN  2
+
+/* To make my life a bit simpler during conversion, effect E:xy is converted
+ * to effect number EBASE+x:y. The same applies to effect X, and IT's S. That
+ * way, these effects can be manipulated like regular effects.
+ */
+#define EBASE              (XM_N_EFFECTS)
+#define XBASE              (EBASE+16)
+#define SBASE              (IT_N_EFFECTS)
+
+#define EFFECT_VALUE(x, y) (((x)<<4)|(y))
+#define HIGH(v)            ((v)>>4)
+#define LOW(v)             ((v)&0x0F)
+#define SET_HIGH(v, x)     v = (((x)<<4)|((v)&0x0F))
+#define SET_LOW(v, y)      v = (((v)&0xF0)|(y))
+#define BCD_TO_NORMAL(v)   (HIGH(v)*10+LOW(v))
+
+
+
+#if 0
+unsigned char **_dumb_malloc2(int w, int h);
+void _dumb_free2(unsigned char **line);
+#endif
+
+void _dumb_it_xm_convert_effect(int effect, int value, IT_ENTRY *entry);
+int _dumb_it_fix_invalid_orders(DUMB_IT_SIGDATA *sigdata);
+
+
+
+#endif /* INTERNAL_IT_H */
diff -uNr fighterz1/client/aldumb.cpp fighterz2/client/aldumb.cpp
--- fighterz1/client/aldumb.cpp	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/aldumb.cpp	2005-01-07 01:25:46.000000000 +0100
@@ -0,0 +1,2 @@
+#include "common.h"
+
diff -uNr fighterz1/client/almp3/almp3dll.h fighterz2/client/almp3/almp3dll.h
--- fighterz1/client/almp3/almp3dll.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/almp3/almp3dll.h	2002-06-15 00:05:38.000000000 +0200
@@ -0,0 +1,20 @@
+/* Allegro MP3 - a wrapper for mpglib from mpg123 */
+/* to play MP3 files with Allegro */
+
+/* MP3 decoder part of mpglib from mpg123 (www.mpg123.com) */
+/* Allegro MP3 is copyright (c) 2001, 2002 Javier Gonz lez */
+
+/* See COPYING.txt (GNU Lesser General Public License 2.1) for license */
+
+
+#ifndef ALMP3_DLL_DECLSPEC
+#  ifdef ALMP3_DLL
+#    ifdef ALMP3_DLL_EXPORTS
+#      define ALMP3_DLL_DECLSPEC __declspec(dllexport)
+#    else
+#      define ALMP3_DLL_DECLSPEC __declspec(dllimport)
+#    endif
+#  else
+#    define ALMP3_DLL_DECLSPEC
+#  endif
+#endif
diff -uNr fighterz1/client/almp3/almp3.h fighterz2/client/almp3/almp3.h
--- fighterz1/client/almp3/almp3.h	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/almp3/almp3.h	2005-01-06 20:32:44.000000000 +0100
@@ -0,0 +1,165 @@
+/* Allegro MP3 - a wrapper for mpglib from mpg123 */
+/* to play MP3 files with Allegro */
+
+/* MP3 decoder part of mpglib from mpg123 (www.mpg123.com) */
+/* Allegro MP3 is copyright (c) 2001, 2002 Javier Gonz lez */
+
+/* See COPYING.txt (GNU Lesser General Public License 2.1) for license */
+
+
+#ifndef ALMP3_H
+#define ALMP3_H
+
+
+#include <allegro.h>
+
+#include "almp3dll.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* common define */
+
+#define ALMP3_MAJOR_VERSION          2
+#define ALMP3_MINOR_VERSION          0
+#define ALMP3_SUB_VERSION            4
+#define ALMP3_VERSION_STR            "2.0.4"
+#define ALMP3_DATE_STR               "08/04/2003"
+#define ALMP3_DATE                   20030408    /* yyyymmdd */
+
+/* error codes */
+                                  
+#define ALMP3_OK                     0
+
+#define ALMP3_PLAY_BUFFERTOOSMALL    -1
+
+#define ALMP3_POLL_PLAYJUSTFINISHED  1
+#define ALMP3_POLL_NOTPLAYING        -1
+#define ALMP3_POLL_FRAMECORRUPT      -2
+#define ALMP3_POLL_BUFFERUNDERRUN    -3
+#define ALMP3_POLL_INTERNALERROR     -4
+
+
+/* API - MP3 */
+
+typedef struct ALMP3_MP3 ALMP3_MP3;
+
+
+ALMP3_DLL_DECLSPEC ALMP3_MP3 *almp3_create_mp3(void *data, int data_len);
+ALMP3_DLL_DECLSPEC void almp3_destroy_mp3(ALMP3_MP3 *mp3);
+
+ALMP3_DLL_DECLSPEC int almp3_play_mp3(ALMP3_MP3 *mp3, int buffer_len, int vol, int pan);
+ALMP3_DLL_DECLSPEC int almp3_play_ex_mp3(ALMP3_MP3 *mp3, int buffer_len, int vol, int pan, int speed, int loop);
+ALMP3_DLL_DECLSPEC void almp3_stop_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC void almp3_rewind_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC void almp3_seek_abs_frames_mp3(ALMP3_MP3 *mp3, int frame);
+ALMP3_DLL_DECLSPEC void almp3_seek_abs_msecs_mp3(ALMP3_MP3 *mp3, int msecs);
+ALMP3_DLL_DECLSPEC void almp3_seek_abs_secs_mp3(ALMP3_MP3 *mp3, int secs);
+ALMP3_DLL_DECLSPEC void almp3_seek_abs_bytes_mp3(ALMP3_MP3 *mp3, int bytes);
+ALMP3_DLL_DECLSPEC void almp3_seek_rel_frames_mp3(ALMP3_MP3 *mp3, int frame);
+ALMP3_DLL_DECLSPEC void almp3_seek_rel_msecs_mp3(ALMP3_MP3 *mp3, int msec);
+ALMP3_DLL_DECLSPEC void almp3_seek_rel_secs_mp3(ALMP3_MP3 *mp3, int sec);
+ALMP3_DLL_DECLSPEC void almp3_seek_rel_bytes_mp3(ALMP3_MP3 *mp3, int bytes);
+ALMP3_DLL_DECLSPEC void almp3_adjust_mp3(ALMP3_MP3 *mp3, int vol, int pan, int speed, int loop);
+
+ALMP3_DLL_DECLSPEC int almp3_poll_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC void almp3_start_autopoll_mp3(ALMP3_MP3 *mp3, int speed);
+ALMP3_DLL_DECLSPEC void almp3_stop_autopoll_mp3(ALMP3_MP3 *mp3);
+
+ALMP3_DLL_DECLSPEC int almp3_get_pos_frames_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_msecs_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_secs_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_bytes_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_length_frames_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_length_secs_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_length_msecs_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_length_bytes_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_msecs_per_frame_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_bitrate_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_layer_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_is_stereo_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_bits_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_is_stereo_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_freq_mp3(ALMP3_MP3 *mp3);
+
+ALMP3_DLL_DECLSPEC SAMPLE *almp3_create_sample_from_mp3(ALMP3_MP3 *mp3);
+
+ALMP3_DLL_DECLSPEC void *almp3get_output_wave_mp3(ALMP3_MP3 *mp3, int *buffer_size);
+
+ALMP3_DLL_DECLSPEC int almp3_is_playing_mp3(ALMP3_MP3 *mp3);
+ALMP3_DLL_DECLSPEC int almp3_is_looping_mp3(ALMP3_MP3 *mp3);
+
+ALMP3_DLL_DECLSPEC AUDIOSTREAM *almp3_get_audiostream_mp3(ALMP3_MP3 *mp3);
+
+
+
+/* API - MP3STREAM */
+
+typedef struct ALMP3_MP3STREAM ALMP3_MP3STREAM;
+
+
+ALMP3_DLL_DECLSPEC ALMP3_MP3STREAM *almp3_create_mp3stream(void *first_data_buffer, int data_buffer_len, int last_block);
+ALMP3_DLL_DECLSPEC ALMP3_MP3STREAM *almp3_create_mp3stream_ex(void *first_data_buffer, int data_buffer_len, int last_block, int downsample, int downmix);
+ALMP3_DLL_DECLSPEC void almp3_destroy_mp3stream(ALMP3_MP3STREAM *mp3);
+
+ALMP3_DLL_DECLSPEC int almp3_play_mp3stream(ALMP3_MP3STREAM *mp3, int buffer_len, int vol, int pan);
+ALMP3_DLL_DECLSPEC int almp3_play_ex_mp3stream(ALMP3_MP3STREAM *mp3, int buffer_len, int vol, int pan, int speed);
+ALMP3_DLL_DECLSPEC void almp3_stop_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC void almp3_adjust_mp3stream(ALMP3_MP3STREAM *mp3, int vol, int pan, int speed);
+
+ALMP3_DLL_DECLSPEC int almp3_poll_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC void almp3_start_autopoll_mp3stream(ALMP3_MP3STREAM *mp3, int speed);
+ALMP3_DLL_DECLSPEC void almp3_stop_autopoll_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC void *almp3_get_mp3stream_buffer(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC void almp3_free_mp3stream_buffer(ALMP3_MP3STREAM *mp3, int bytes_used);
+
+ALMP3_DLL_DECLSPEC int almp3_get_length_frames_mp3stream(ALMP3_MP3STREAM *mp3, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_get_length_secs_mp3stream(ALMP3_MP3STREAM *mp3, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_get_length_msecs_mp3stream(ALMP3_MP3STREAM *mp3, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_get_length_bytes_mp3stream(ALMP3_MP3STREAM *mp3, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_frames_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_msecs_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_secs_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_pos_bytes_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_msecs_per_frame_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_bitrate_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_layer_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_is_stereo_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_bits_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_is_stereo_mp3stream(ALMP3_MP3STREAM *mp3);
+ALMP3_DLL_DECLSPEC int almp3_get_wave_freq_mp3stream(ALMP3_MP3STREAM *mp3);
+
+ALMP3_DLL_DECLSPEC void *almp3_get_output_wave_mp3stream(ALMP3_MP3STREAM *mp3, int *buffer_size);
+
+ALMP3_DLL_DECLSPEC int almp3_is_playing_mp3stream(ALMP3_MP3STREAM *mp3);
+
+ALMP3_DLL_DECLSPEC AUDIOSTREAM *almp3_get_audiostream_mp3stream(ALMP3_MP3STREAM *mp3);
+
+ALMP3_DLL_DECLSPEC int almp3_seek_abs_frames_mp3stream(ALMP3_MP3STREAM *mp3, int frame, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_abs_msecs_mp3stream(ALMP3_MP3STREAM *mp3, int msecs, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_abs_secs_mp3stream(ALMP3_MP3STREAM *mp3, int secs, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_abs_bytes_mp3stream(ALMP3_MP3STREAM *mp3, int bytes, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_rel_frames_mp3stream(ALMP3_MP3STREAM *mp3, int frame, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_rel_msecs_mp3stream(ALMP3_MP3STREAM *mp3, int msec, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_rel_secs_mp3stream(ALMP3_MP3STREAM *mp3, int sec, int total_size);
+ALMP3_DLL_DECLSPEC int almp3_seek_rel_bytes_mp3stream(ALMP3_MP3STREAM *mp3, int bytes, int total_size);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
+#define DATASZ  (1<<15) /* (32768) amount of data to read from disk each time */
+#define BUFSZ   (1<<16) /* (65536) size of audiostream buffer */
+
+
+typedef struct {
+  PACKFILE *f;
+  ALMP3_MP3STREAM *s;
+} MP3FILE;
diff -uNr fighterz1/client/almp3.cpp fighterz2/client/almp3.cpp
--- fighterz1/client/almp3.cpp	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/almp3.cpp	2005-01-06 20:58:04.000000000 +0100
@@ -0,0 +1,63 @@
+#include "common.h"
+
+
+MP3FILE *open_mp3_file(char *filename) {
+  MP3FILE *p = NULL;
+  PACKFILE *f = NULL;
+  ALMP3_MP3STREAM *s = NULL;
+  char data[DATASZ];
+  int len;
+
+  if (!(p = (MP3FILE *)malloc(sizeof(MP3FILE))))
+    goto error;
+  if (!(f = pack_fopen(filename, F_READ)))
+    goto error;
+  if ((len = pack_fread(data, DATASZ, f)) <= 0)
+    goto error;
+  if (len < DATASZ) {
+    if (!(s = almp3_create_mp3stream(data, len, TRUE)))
+      goto error;
+  }
+  else {
+    if (!(s = almp3_create_mp3stream(data, DATASZ, FALSE)))
+      goto error;
+  }
+  p->f = f;
+  p->s = s;
+  return p;
+
+  error:
+  pack_fclose(f);
+  free(p);
+  return NULL;
+}
+
+int play_mp3_file(MP3FILE *mp3, int buflen, int vol, int pan) {
+
+  return almp3_play_mp3stream(mp3->s, buflen, vol, pan);
+}
+
+void close_mp3_file(MP3FILE *mp3) {
+  if (mp3) {
+    pack_fclose(mp3->f);
+    almp3_destroy_mp3stream(mp3->s);
+    free(mp3);
+  }
+}
+
+
+int poll_mp3_file(MP3FILE *mp3) {
+  char *data;
+  long len;
+
+  data = (char *)almp3_get_mp3stream_buffer(mp3->s);
+  if (data) {
+    len = pack_fread(data, DATASZ, mp3->f);
+    if (len < DATASZ)
+      almp3_free_mp3stream_buffer(mp3->s, len);
+    else
+      almp3_free_mp3stream_buffer(mp3->s, -1);
+  }
+
+  return almp3_poll_mp3stream(mp3->s);
+}
\ No newline at end of file
diff -uNr fighterz1/client/common.h fighterz2/client/common.h
--- fighterz1/client/common.h	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/common.h	2005-01-07 01:26:40.000000000 +0100
@@ -48,6 +48,9 @@
 #include <stdlib.h>
 #include <allegro.h>
 #include "alfont/alfont.h"
+//#include "almp3/almp3.h"
+//almp3.lib disabled...
+#include "aldumb/aldumb.h"
 #include <math.h>
 #include <winalleg.h>
 #include <winsock.h>
@@ -71,4 +74,13 @@
 
 // not using: #include <aldumb.h> // for XM etc
 
-#endif
\ No newline at end of file
+//almp3.cpp
+//extern MP3FILE *open_mp3_file(char *filename);
+//extern int play_mp3_file(MP3FILE *mp3, int buflen, int vol, int pan);
+//extern void close_mp3_file(MP3FILE *mp3);
+//extern int poll_mp3_file(MP3FILE *mp3);
+
+//main/aldumb
+extern DUH *duh;
+extern AL_DUH_PLAYER *dp;
+#endif
diff -uNr fighterz1/client/genproc.cpp fighterz2/client/genproc.cpp
--- fighterz1/client/genproc.cpp	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/genproc.cpp	2005-01-07 01:20:00.000000000 +0100
@@ -10,6 +10,8 @@
 int terminate_request = 0;
 int midi_track = 3;
 
+//MP3FILE *mp3_intro;
+
 void closereq()
 {
 	terminate_request = 1;
@@ -95,15 +97,28 @@
 	
 
 	printff_direct("Loading Sound");
-
+/*
 	if (install_sound(DIGI_AUTODETECT, MIDI_AUTODETECT, NULL) < 0)
 	{
 		printff_direct("ERROR initializing sound!");
 		terminate();
 	}
+*/
+
+	
+  /* to achieve the max possible volume */
+  set_volume_per_voice(0);
+
+  if (install_sound(DIGI_AUTODETECT, MIDI_NONE, 0) < 0) {
+    set_gfx_mode(GFX_TEXT, 0, 0, 0, 0);
+    allegro_message("Error installing sound.\n");
+    return;
+  }
+
+	//intro_music = (MIDI *)dat_sound[METAMORPHOSIS4].dat;
+  duh = dumb_load_xm("system\\intro.xm");
+	
 
-		//play_rand_bg_music();
-		intro_music = (MIDI *)dat_sound[METAMORPHOSIS4].dat;
 
 }
 
diff -uNr fighterz1/client/main.cpp fighterz2/client/main.cpp
--- fighterz1/client/main.cpp	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/main.cpp	2005-01-07 01:26:24.000000000 +0100
@@ -6,6 +6,10 @@
 
 #include "common.h"
 
+DUH *duh;
+AL_DUH_PLAYER *dp;
+
+
 //general
 int screensize_y = 600; /**< screen height size in pixels */
 int screensize_x = 800; /**< screen width size in pixels */
@@ -17,6 +21,7 @@
 //sound
 MIDI *bg_music; /**< used to play background midi ingame */
 MIDI *intro_music; /**< used to play background midi in options */
+void *intro_mp3; /* MP3 */
 //data
 DATAFILE *dat_base; /** datafile: contains all fonts & graphics used in the game */
 DATAFILE *dat_sound; /** datafile: sound container (midi,wav,etc..) */
@@ -52,6 +57,7 @@
 #endif
 
 // int main(char *argv[], int argc)
+
 int WINAPI WinMain(HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument,
 				   int nFunsterStil)
 {
@@ -113,6 +119,9 @@
 
 		if (skip_options != 1)
 		{
+//			if ((mp3_intro = open_mp3_file("system\\intro.mp3")))
+//				play_mp3_file(mp3_intro, BUFSZ, 255, 128);
+
 			set_volume(255, 255);
 			play_midi(intro_music, TRUE);
 
@@ -134,6 +143,11 @@
 
 while (!key[KEY_ESC])
 {
+
+//		if (mp3_intro == NULL)	
+//			if ((mp3_intro = open_mp3_file("system\\intro.mp3")))
+//					play_mp3_file(mp3_intro, BUFSZ, 255, 128);
+
 	//alert("in while!", "", "", "OK", NULL, KEY_ENTER, 1);
 		if (skip_options != 1)
 			ret = get_options();
@@ -141,6 +155,8 @@
 			ret = 0;
 
 		fakeconsole_y = 0;
+//		close_mp3_file(mp3_intro);
+//		mp3_intro = NULL;
 
 		switch (ret)
 		{
diff -uNr fighterz1/client/options.cpp fighterz2/client/options.cpp
--- fighterz1/client/options.cpp	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/options.cpp	2005-01-07 01:12:40.000000000 +0100
@@ -78,6 +78,18 @@
 	{
 	char k; // Used to store Keyboard input
 
+/*		//pollmp3
+		if ((mp3_intro) && (poll_mp3_file(mp3_intro) != ALMP3_OK)) {
+			close_mp3_file(mp3_intro);
+			mp3_intro = NULL;
+
+			//LOOP
+			if ((mp3_intro = open_mp3_file("system\\intro.mp3")))
+					play_mp3_file(mp3_intro, BUFSZ, 255, 128);
+		}
+		//--
+*/
+	
 		clear_to_color(tmpscreen, makecol(0,0,0)); /* clear "double" buffer */
 		time_proc(); // update time every iteration
 
diff -uNr fighterz1/client/project_files/allegro.cfg fighterz2/client/project_files/allegro.cfg
--- fighterz1/client/project_files/allegro.cfg	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/project_files/allegro.cfg	2005-01-20 15:17:58.000000000 +0100
@@ -0,0 +1,6 @@
+[grabber]
+xgrid = 16
+ygrid = 16
+backups = n
+dither = n
+transparency = n
Binary files fighterz1/client/project_files/almp3.dll and fighterz2/client/project_files/almp3.dll differ
diff -uNr fighterz1/client/project_files/fighterz_client.dsp fighterz2/client/project_files/fighterz_client.dsp
--- fighterz1/client/project_files/fighterz_client.dsp	2004-12-12 21:28:18.000000000 +0100
+++ fighterz2/client/project_files/fighterz_client.dsp	2005-01-07 01:27:44.000000000 +0100
@@ -53,7 +53,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
-# ADD LINK32 alleg.lib alfont.lib wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
+# ADD LINK32 alleg.lib alfont.lib almp3dll.lib dumb.lib wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386
 
 !ELSEIF  "$(CFG)" == "fighterz_client - Win32 Debug"
 
@@ -79,7 +79,8 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 alld.lib alfont.lib wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 alld.lib alfont.lib dumb.lib wsock32.lib user32.lib /nologo /subsystem:windows /debug /machine:I386 /pdbtype:sept
+# SUBTRACT LINK32 /nodefaultlib
 
 !ENDIF 
 
@@ -164,6 +165,10 @@
 # PROP Default_Filter "h;hpp;hxx;hm;inl"
 # Begin Source File
 
+SOURCE=..\aldumb\aldumb.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\alfont\alfont.h
 # End Source File
 # Begin Source File
Binary files fighterz1/client/project_files/fighterz_client.exe and fighterz2/client/project_files/fighterz_client.exe differ
Binary files fighterz1/client/project_files/fighterz_client.ncb and fighterz2/client/project_files/fighterz_client.ncb differ
Binary files fighterz1/client/project_files/fighterz_client.opt and fighterz2/client/project_files/fighterz_client.opt differ
diff -uNr fighterz1/client/project_files/fighterz_client.plg fighterz2/client/project_files/fighterz_client.plg
--- fighterz1/client/project_files/fighterz_client.plg	1970-01-01 01:00:00.000000000 +0100
+++ fighterz2/client/project_files/fighterz_client.plg	2005-01-20 14:54:10.000000000 +0100
@@ -0,0 +1,48 @@
+<html>
+<body>
+<pre>
+<h1>Build Log</h1>
+<h3>
+--------------------Configuration: fighterz_client - Win32 Release--------------------
+</h3>
+<h3>Command Lines</h3>
+Creating temporary file "C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\RSP393.tmp" with contents
+[
+alleg.lib alfont.lib almp3dll.lib dumb.lib wsock32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /incremental:no /pdb:"Release/fighterz_client.pdb" /machine:I386 /out:"Release/fighterz_client.exe" 
+.\Release\agup.obj
+.\Release\aphoton.obj
+.\Release\collition.obj
+.\Release\config.obj
+.\Release\console.obj
+.\Release\cube.obj
+.\Release\genproc.obj
+.\Release\global.obj
+.\Release\interface.obj
+.\Release\main.obj
+.\Release\map.obj
+.\Release\objects.obj
+.\Release\options.obj
+.\Release\proto.obj
+.\Release\send.obj
+.\Release\settings.obj
+.\Release\socket.obj
+.\Release\icon.res
+]
+Creating command line "link.exe @C:\DOCUME~1\ADMINI~1\LOCALS~1\Temp\RSP393.tmp"
+<h3>Output Window</h3>
+Linking...
+MSVCRT.lib(MSVCRT.dll) : error LNK2005: _free already defined in LIBC.lib(free.obj)
+MSVCRT.lib(MSVCRT.dll) : error LNK2005: _malloc already defined in LIBC.lib(malloc.obj)
+MSVCRT.lib(MSVCRT.dll) : error LNK2005: _realloc already defined in LIBC.lib(realloc.obj)
+MSVCRT.lib(MSVCRT.dll) : error LNK2005: _printf already defined in LIBC.lib(printf.obj)
+LINK : warning LNK4098: defaultlib "MSVCRT" conflicts with use of other libs; use /NODEFAULTLIB:library
+Release/fighterz_client.exe : fatal error LNK1169: one or more multiply defined symbols found
+Error executing link.exe.
+
+
+
+<h3>Results</h3>
+fighterz_client.exe - 5 error(s), 1 warning(s)
+</pre>
+</body>
+</html>
Binary files fighterz1/client/project_files/system/base_snd.dat and fighterz2/client/project_files/system/base_snd.dat differ
Binary files fighterz1/client/project_files/system/intro.mp3f and fighterz2/client/project_files/system/intro.mp3f differ
Binary files fighterz1/client/project_files/system/intro.xm and fighterz2/client/project_files/system/intro.xm differ
diff -uNr fighterz1/client/socket.cpp fighterz2/client/socket.cpp
--- fighterz1/client/socket.cpp	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/socket.cpp	2005-01-06 20:02:10.000000000 +0100
@@ -823,7 +823,7 @@
 void m_spawn(unsigned int id, double x, double y, double deg, signed char accel, 
 	unsigned int alive, short frags, signed char turn, unsigned char type, double speed)
 {
-node = getplayer_byid( id );
+PLAYER node = getplayer_byid( id );
 	//	addtext("************************************");
 	//	addtext("spwn: id: %u, x: %2.2f, y: %2.2f", id, x, y);
 	//	addtext("spwn: deg: %2.2f, accel: %d, alive: %u", deg, accel, alive);
diff -uNr fighterz1/client/sound.h fighterz2/client/sound.h
--- fighterz1/client/sound.h	2004-07-17 19:09:50.000000000 +0200
+++ fighterz2/client/sound.h	2005-01-06 20:05:46.000000000 +0100
@@ -1,6 +1,6 @@
 /* Allegro datafile object indexes, produced by grabber v4.0.0, MinGW32.s */
-/* Datafile: d:\dev\fighterz\client\project_files\system\base_snd.dat */
-/* Date: Fri May 07 22:12:55 2004 */
+/* Datafile: d:\dev\Fighterz\client\project_files\system\base_snd.dat */
+/* Date: Thu Jan 06 20:05:07 2005 */
 /* Do not hand edit! */
 
 #define BG_MUSIC                         0        /* MIDI */
@@ -11,8 +11,10 @@
 #define BG_MUSIC6                        5        /* MIDI */
 #define CONFIRM                          6        /* SAMP */
 #define FAST_CONFIRM                     7        /* SAMP */
-#define METAMORPHOSIS4                   8        /* MIDI */
-#define SHOOT                            9        /* SAMP */
-#define SPAWN                            10       /* SAMP */
-#define TUSCH                            11       /* SAMP */
+#define INTRO_MP3                        8        /* MP3  */
+#define METAMORPHOSIS4                   9        /* MIDI */
+#define SHOOT                            10       /* SAMP */
+#define SPAWN                            11       /* SAMP */
+#define TUSCH                            12       /* SAMP */
 
+ 
\ No newline at end of file
diff -uNr fighterz1/client/variables.h fighterz2/client/variables.h
--- fighterz1/client/variables.h	2004-12-12 21:28:16.000000000 +0100
+++ fighterz2/client/variables.h	2005-01-07 01:15:44.000000000 +0100
@@ -4,7 +4,7 @@
 
 extern MIDI *bg_music;
 extern MIDI *intro_music;
-
+extern void *intro_mp3;
 
 extern int screensize_y;
 extern int screensize_x;
@@ -101,7 +101,7 @@
 //genproc.cpp
 extern int radar_padding_x;
 extern int radar_padding_y;
-
+//extern MP3FILE *mp3_intro;
 
 //collition.cpp
 extern double X2(double x, double y, double angle, double radius);
Binary files fighterz1/fighterz_untitled.bmp and fighterz2/fighterz_untitled.bmp differ
